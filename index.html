<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIT1047 面试准备工具</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --card-bg: #2b2b2b;
            --text-color: #e0e0e0;
            --primary-color: #4a90e2;
            --border-color: #444;
            --success-color: #50fa7b;
            --code-bg: #1e1e1e;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        h1 {
            color: var(--primary-color);
            margin: 0;
        }
        h2 {
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-top: 40px;
        }
        .section {
            margin-bottom: 30px;
        }
        .accordion {
            background-color: var(--card-bg);
            color: var(--text-color);
            cursor: pointer;
            padding: 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 18px;
            transition: 0.4s;
            border-radius: 5px;
            border-left: 5px solid var(--border-color);
            margin-top: 10px;
        }
        .accordion.active, .accordion:hover {
            background-color: #3c3c3c;
            border-left: 5px solid var(--primary-color);
        }
        .panel {
            padding: 0 18px;
            background-color: var(--card-bg);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            border-radius: 0 0 5px 5px;
            border-left: 5px solid var(--primary-color);
            margin-bottom: 10px;
        }
        .panel-content {
            padding: 15px 0;
        }
        .flashcard {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 15px;
        }
        .flashcard-question {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 15px;
        }
        .flashcard-answer {
            display: none;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
            margin-top: 15px;
        }
        .toggle-answer-btn {
            background-color: var(--primary-color);
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .toggle-answer-btn:hover {
            opacity: 0.9;
        }
        code, pre {
            background-color: var(--code-bg);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: "Courier New", Courier, monospace;
            color: var(--success-color);
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .code-explanation {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }
        .code-block {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }
        .explanation-block {
             padding: 10px;
        }
         @media (max-width: 768px) {
            .code-explanation {
                grid-template-columns: 1fr;
            }
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>FIT1047 - Assignment 2 交互式面试复习</h1>
            <p>点击各项标题或按钮来展开和查看详细解答。</p>
        </header>

        <!-- Section 1: Code Walkthrough -->
        <section class="section">
            <h2>Part 1: 代码逻辑讲解 (保姆级)</h2>
            <p>这部分将你的源代码与逐行解释并列，确保你理解每一句代码的含义。</p>
            
            <button class="accordion">SubClearDisplay (Task 3.1) - 逐行代码分析</button>
            <div class="panel">
                <div class="panel-content">
                    <h4>功能概述</h4>
                    <p>将16x16的显示屏（内存地址 <code>0F00</code> 到 <code>0FFF</code>）全部填充为白色 (<code>FFFF</code>)。</p>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
SubClearDisplay, HEX 0
    Load Display_StartAddress
    Store ClearDisplay_Pointer
    Load Display_PixelCount
    Store ClearDisplay_Counter</pre></div>
                        <div class="explanation-block">
                            <b>初始化阶段:</b>
                            <ul>
                                <li><code>SubClearDisplay, HEX 0</code>: 定义子程序入口。<code>HEX 0</code> 是一个占位符，用于存储主程序调用它时自动产生的返回地址。</li>
                                <li><code>Load Display_StartAddress</code>: 将显示屏的起始地址 (<code>0F00</code>) 加载到累加器(AC)中。</li>
                                <li><code>Store ClearDisplay_Pointer</code>: 将AC中的地址 (<code>0F00</code>) 存入我们定义的指针变量 <code>ClearDisplay_Pointer</code>。</li>
                                <li><code>Load Display_PixelCount</code>: 将像素总数 (<code>256</code>) 加载到AC。</li>
                                <li><code>Store ClearDisplay_Counter</code>: 将AC中的计数值 (<code>256</code>) 存入计数器变量 <code>ClearDisplay_Counter</code>。</li>
                            </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
CD_Loop, Load Color_White
    StoreI ClearDisplay_Pointer
    Load ClearDisplay_Pointer
    Add ONE
    Store ClearDisplay_Pointer
    Load ClearDisplay_Counter
    Subt ONE
    Store ClearDisplay_Counter
    Load ClearDisplay_Counter
    Skipcond 400
    Jump CD_Loop</pre></div>
                        <div class="explanation-block">
                             <b>循环擦除阶段:</b>
                             <ul>
                                <li><code>CD_Loop, Load Color_White</code>: 循环开始点。将白色值 (<code>FFFF</code>) 加载到AC。</li>
                                <li><code>StoreI ClearDisplay_Pointer</code>: <b>(关键!)</b> 间接存储。把AC中的 <code>FFFF</code> 存到 <code>ClearDisplay_Pointer</code> 指针所指向的地址。第一次循环时，就是存到 <code>0F00</code>。</li>
                                <li><code>Load ClearDisplay_Pointer...Add ONE...Store...</code>: 这三步将指针自身的值加1，使其指向下一个像素地址 (如 <code>0F01</code>)。</li>
                                <li><code>Load ClearDisplay_Counter...Subt ONE...Store...</code>: 这三步将计数器自身的值减1。</li>
                                <li><code>Load ClearDisplay_Counter</code>, <code>Skipcond 400</code>, <code>Jump CD_Loop</code>: 检查计数器是否为0。如果不是0，则跳转回 <code>CD_Loop</code> 继续；如果是0，则跳过 `Jump` 指令，循环结束。</li>
                             </ul>
                        </div>
                    </div>
                     <div class="code-explanation">
                        <div class="code-block"><pre>
    JumpI SubClearDisplay</pre></div>
                        <div class="explanation-block">
                             <b>返回主程序:</b>
                             <ul>
                                <li><code>JumpI SubClearDisplay</code>: <b>(关键!)</b> 间接跳转。程序会跳转到储存在 <code>SubClearDisplay</code> 地址处的值，也就是我们一开始保存的返回地址，从而安全地回到主程序。</li>
                             </ul>
                        </div>
                    </div>
                </div>
            </div>

            <button class="accordion">SubInputString (Task 3.2) - 逐行代码分析</button>
            <div class="panel">
                 <div class="panel-content">
                    <h4>功能概述</h4>
                    <p>循环接收用户输入，将小写字母转为大写存入内存，直到遇到非字母字符为止。</p>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
SubInputString, HEX 0
    Load InputStringAddr
    Store InputString_TempPointer

ReadNextChar, Input 
    Store InputString_TempCharacter</pre></div>
                        <div class="explanation-block">
                            <b>初始化与输入:</b>
                            <ul>
                                <li><code>SubInputString, HEX 0</code>: 子程序入口和返回地址占位符。</li>
                                <li><code>Load InputStringAddr...</code>: 获取主程序设置的、用于存储字符串的起始地址，并将其保存在内部指针 <code>InputString_TempPointer</code> 中。</li>
                                <li><code>ReadNextChar, Input...</code>: 循环开始点。等待用户输入一个字符，并将其ASCII码存入临时变量 <code>InputString_TempCharacter</code>。</li>
                            </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
    Load InputString_TempCharacter
    Subt ASCII_Code_A
    Skipcond 000
    Jump MaybeUpper
    Jump CheckLower

MaybeUpper, Load ...
    Subt ASCII_Code_Z
    Skipcond 800
    Jump StoreTheChar
    Jump CheckLower</pre></div>
                        <div class="explanation-block">
                             <b>判断是否为大写字母:</b>
                             <ul>
                                <li><code>Subt ASCII_Code_A</code>: 用输入字符减去'A'的ASCII码。</li>
                                <li><code>Skipcond 000</code>: 如果结果小于0 (AC < 0)，说明字符肯定在'A'之前，不是大写字母，跳过下一行。</li>
                                <li><code>Jump MaybeUpper</code>: 如果AC >= 0，可能在'A'之后，跳转去进一步判断。</li>
                                <li><code>Subt ASCII_Code_Z</code>: 用输入字符减去'Z'的ASCII码。</li>
                                <li><code>Skipcond 800</code>: 如果结果大于0 (AC > 0)，说明字符在'Z'之后，不是大写字母，跳过下一行。</li>
                                <li><code>Jump StoreTheChar</code>: 如果AC <= 0，说明字符在'A'和'Z'之间，是合法大写字母，直接跳转去存储。</li>
                             </ul>
                        </div>
                    </div>
                     <div class="code-explanation">
                        <div class="code-block"><pre>
CheckLower, Load ...
    Subt ASCII_Code_a
    Skipcond 000
    Jump MaybeLower
    Jump Finish

MaybeLower, Load ...
    Subt ASCII_Code_z
    Skipcond 800
    Jump ConvertIt
    Jump Finish</pre></div>
                        <div class="explanation-block">
                             <b>判断是否为小写字母:</b>
                             <ul>
                                 <li>逻辑与判断大写字母完全相同，只是比较的范围变成了'a'到'z'。</li>
                                 <li>如果字符不在'a'之前，也不在'z'之后，说明它是合法的小写字母。</li>
                                 <li><code>Jump ConvertIt</code>: 跳转去进行大小写转换。</li>
                                 <li><code>Jump Finish</code>: 如果以上所有判断都不满足，说明它是一个非字母字符，跳转到结束程序。</li>
                             </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
ConvertIt, Load InputString_TempCharacter
    Subt ASCII_CaseDifference
    Store InputString_TempCharacter
    Jump StoreTheChar</pre></div>
                        <div class="explanation-block">
                             <b>转换为大写:</b>
                             <ul>
                                <li><code>Subt ASCII_CaseDifference</code>: 将小写字母的ASCII码减去32，就得到对应大写字母的ASCII码。</li>
                                <li><code>Store InputString_TempCharacter</code>: 将转换后的结果存回临时变量。</li>
                                <li><code>Jump StoreTheChar</code>: 跳转去存储这个字符。</li>
                             </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
StoreTheChar, Load ...
    StoreI InputString_TempPointer
    Load InputString_TempPointer
    Add ONE
    Store InputString_TempPointer
    Jump ReadNextChar</pre></div>
                        <div class="explanation-block">
                             <b>存储字符并继续:</b>
                             <ul>
                                <li><code>StoreI InputString_TempPointer</code>: <b>(关键!)</b> 间接存储。将字符存入指针指向的内存地址。</li>
                                <li><code>Load ... Add ONE ... Store ...</code>: 将指针自身的值加1，为下一个字符做准备。</li>
                                <li><code>Jump ReadNextChar</code>: 返回循环开头，等待下一个字符输入。</li>
                             </ul>
                        </div>
                    </div>
                     <div class="code-explanation">
                        <div class="code-block"><pre>
Finish, Clear
    StoreI InputString_TempPointer
    JumpI SubInputString</pre></div>
                        <div class="explanation-block">
                             <b>结束并返回:</b>
                             <ul>
                                <li><code>Finish, Clear</code>: 将累加器AC清零。</li>
                                <li><code>StoreI InputString_TempPointer</code>: 将0存入字符串的末尾，作为结束标志。</li>
                                <li><code>JumpI SubInputString</code>: 返回主程序。</li>
                             </ul>
                        </div>
                    </div>
                </div>
            </div>

            <button class="accordion">SubPaintChar (Task 3.3) - 逐行代码分析</button>
            <div class="panel">
                <div class="panel-content">
                    <h4>功能概述</h4>
                    <p>在屏幕的指定位置绘制一个4x8像素的字符。这是一个内存复制过程，将字体数据从Font区复制到显示区。</p>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
SubPaintChar, HEX 0
    Load PaintCharCharacter
    Store PaintChar_CharacterPointer
    Load PaintCharDisplay
    Store PaintChar_DisplayPointer
    Load Const_RowCount
    Store PaintChar_RowCounter</pre></div>
                        <div class="explanation-block">
                            <b>初始化阶段:</b>
                            <ul>
                                <li><code>SubPaintChar, HEX 0</code>: 子程序入口和返回地址占位符。</li>
                                <li><code>Load PaintCharCharacter...</code>: 将主程序传入的“字符数据地址”存入内部指针 <code>PaintChar_CharacterPointer</code>。</li>
                                <li><code>Load PaintCharDisplay...</code>: 将主程序传入的“屏幕绘制地址”存入内部指针 <code>PaintChar_DisplayPointer</code>。</li>
                                <li><code>Load Const_RowCount...</code>: 将行数(8)存入行计数器 <code>PaintChar_RowCounter</code>，准备开始外层循环。</li>
                            </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
PC_Row, Load Const_ColumnCount
    Store PaintChar_ColumnCounter
PC_Col, LoadI PaintChar_CharacterPointer
    StoreI PaintChar_DisplayPointer
    Load PaintChar_CharacterPointer
    Add ONE
    Store PaintChar_CharacterPointer
    Load PaintChar_DisplayPointer
    Add ONE
    Store PaintChar_DisplayPointer
    Load PaintChar_ColumnCounter
    Subt ONE
    Store PaintChar_ColumnCounter
    Load PaintChar_ColumnCounter
    Skipcond 400
    Jump PC_Col</pre></div>
                        <div class="explanation-block">
                             <b>内层循环 (绘制一行):</b>
                             <ul>
                                <li><code>PC_Row, Load...</code>: 外层循环开始点。每次开始新的一行时，都将列数(4)存入列计数器。</li>
                                <li><code>PC_Col, LoadI...</code>: 内层循环开始点。间接加载一个像素的颜色。</li>
                                <li><code>StoreI PaintChar_DisplayPointer</code>: <b>(关键!)</b> 间接存储，将这个像素颜色画到屏幕上。</li>
                                <li><code>Load...Add ONE...Store...</code>: 字体指针和屏幕指针都加1，移到下一个位置。</li>
                                <li><code>Load...Subt ONE...Store...</code>: 列计数器减1。</li>
                                <li><code>Skipcond 400, Jump PC_Col</code>: 如果列计数器不为0，则返回 <code>PC_Col</code> 继续画当前行的下一个像素。当4个像素都画完后，内层循环结束。</li>
                             </ul>
                        </div>
                    </div>
                     <div class="code-explanation">
                        <div class="code-block"><pre>
    Load PaintChar_DisplayPointer
    Add Display_RowOffset
    Store PaintChar_DisplayPointer
    Load PaintChar_RowCounter
    Subt ONE
    Store PaintChar_RowCounter
    Load PaintChar_RowCounter
    Skipcond 400
    Jump PC_Row</pre></div>
                        <div class="explanation-block">
                             <b>外层循环 (换行与判断):</b>
                             <ul>
                                <li><code>Load PaintChar_DisplayPointer...</code>: <b>(关键!)</b> 加载当前屏幕指针地址。</li>
                                <li><code>Add Display_RowOffset</code>: 加上换行偏移量12 (16-4)，计算出下一行在屏幕上的正确起始地址。</li>
                                <li><code>Store PaintChar_DisplayPointer</code>: 保存这个新地址。</li>
                                <li><code>Load...Subt ONE...Store...</code>: 行计数器减1。</li>
                                <li><code>Skipcond 400, Jump PC_Row</code>: 如果行计数器不为0，则返回 <code>PC_Row</code> 继续画下一行。当8行都画完后，外层循环结束。</li>
                             </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
    Load PaintChar_DelayCounter
PC_DelayL, Subt ONE
    Skipcond 400
    Jump PC_DelayL
    JumpI SubPaintChar</pre></div>
                        <div class="explanation-block">
                            <b>延时与返回:</b>
                            <ul>
                                <li>这一段是一个简单的延时循环，通过重复减一操作来消耗时间，让绘制出的字符在屏幕上停留片刻。</li>
                                <li><code>JumpI SubPaintChar</code>: 延时结束后，间接跳转，安全返回主程序。</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <button class="accordion">SubPaintString (Task 3.4) - 逐行代码分析</button>
            <div class="panel">
                 <div class="panel-content">
                    <h4>功能概述</h4>
                    <p>作为总指挥，接收一个字符串地址，然后逐个字符地在屏幕上动态显示出来。</p>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
SubPaintString, HEX 0
    Load StringAddrForPainting
    Store PaintString_Pointer
    Load Display_StartAddress
    Store PaintString_DisplayPointer</pre></div>
                        <div class="explanation-block">
                            <b>初始化阶段:</b>
                            <ul>
                                <li><code>SubPaintString, HEX 0</code>: 子程序入口和返回地址占位符。</li>
                                <li><code>Load StringAddrForPainting...</code>: 将主程序传入的字符串地址存入内部指针 <code>PaintString_Pointer</code>。</li>
                                <li><code>Load Display_StartAddress...</code>: 将屏幕的左上角地址(<code>0F00</code>)存入内部的显示位置指针 <code>PaintString_DisplayPointer</code>。</li>
                            </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
PS_Loop, JnS SubClearDisplay
    LoadI PaintString_Pointer
    Skipcond 400
    Jump PS_Have
    Jump PS_Done</pre></div>
                        <div class="explanation-block">
                             <b>主循环与字符读取:</b>
                             <ul>
                                 <li><code>PS_Loop, JnS SubClearDisplay</code>: 主循环开始点。每次循环都先调用清屏子程序，实现动画效果。</li>
                                 <li><code>LoadI PaintString_Pointer</code>: 间接加载，从内存中读取当前指针指向的字符。</li>
                                 <li><code>Skipcond 400</code>: 判断字符是否为0 (字符串结束符)。</li>
                                 <li><code>Jump PS_Have</code>: 如果不是0，跳转去处理这个字符。</li>
                                 <li><code>Jump PS_Done</code>: 如果是0，说明字符串结束，跳转去结束子程序。</li>
                             </ul>
                        </div>
                    </div>
                     <div class="code-explanation">
                        <div class="code-block"><pre>
PS_Have, Store PaintString_Character
    Load PaintString_Character
    Subt ASCII_Code_A
    Store PaintString_FontIndex
    Load PaintString_FontIndex
    Add PaintString_FontIndex / *2
    Store PaintString_FontIndex
    ... (repeated 4 more times for *32)
</pre></div>
                        <div class="explanation-block">
                             <b>计算字体偏移量:</b>
                             <ul>
                                 <li><code>Subt ASCII_Code_A</code>: 计算字符的索引值 (A=0, B=1, ...)。</li>
                                 <li><code>Add PaintString_FontIndex</code>: <b>(关键!)</b> 这一系列操作是用来实现乘法。每次将一个数与自身相加，等于乘以2。重复5次就是乘以32 (2^5)。因为每个字符的字体数据占32个字，所以需要用索引乘以32来得到地址偏移量。</li>
                             </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
    Load FontAddr
    Add PaintString_FontIndex
    Store PaintCharCharacter
    Load PaintString_DisplayPointer
    Store PaintCharDisplay
    JnS SubPaintChar</pre></div>
                        <div class="explanation-block">
                             <b>设置参数并调用绘图:</b>
                             <ul>
                                 <li><code>Load FontAddr, Add...</code>: 将字体库的基地址与刚刚算出的偏移量相加，得到当前字符的精确字体数据地址。</li>
                                 <li><code>Store PaintCharCharacter</code>: 将这个地址存入 <code>SubPaintChar</code> 的第一个参数。</li>
                                 <li><code>Store PaintCharDisplay</code>: 将屏幕绘制位置存入 <code>SubPaintChar</code> 的第二个参数。</li>
                                 <li><code>JnS SubPaintChar</code>: 调用绘图子程序，将字符画在屏幕上。</li>
                             </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
    Load PaintString_DelayCounter
PS_Delay, Subt ONE
    Skipcond 400
    Jump PS_Delay

    Load PaintString_Pointer
    Add ONE
    Store PaintString_Pointer
    Jump PS_Loop</pre></div>
                        <div class="explanation-block">
                             <b>延时与更新:</b>
                             <ul>
                                 <li><code>Load PaintString_DelayCounter...</code>: 一个简单的延时循环，让字符显示片刻。</li>
                                 <li><code>Load PaintString_Pointer...</code>: 将字符串指针加1，使其指向下一个待显示的字符。</li>
                                 <li><code>Jump PS_Loop</code>: 返回主循环的开头，处理下一个字符。</li>
                             </ul>
                        </div>
                    </div>
                    <div class="code-explanation">
                        <div class="code-block"><pre>
PS_Done, JumpI SubPaintString</pre></div>
                        <div class="explanation-block">
                             <b>结束并返回:</b>
                             <ul>
                                 <li><code>PS_Done, JumpI SubPaintString</code>: 当所有字符都显示完毕后，程序跳转到这里，通过间接跳转安全地返回主程序。</li>
                             </ul>
                        </div>
                    </div>
                </div>
            </div>
            
        </section>

        <!-- The rest of the HTML remains unchanged -->
        <section class="section">
            <h2>Part 2: 现场代码修改挑战</h2>
            <p>这部分模拟面试官可能提出的 "what if" 问题，考察你的应变和迁移能力。</p>

            <div class="flashcard">
                <div class="flashcard-question">问题 1: 如何修改代码，让字符串从屏幕中央开始显示，而不是左上角？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p><b>思路:</b> 需要修改 <code>SubPaintString</code> 子程序中设置初始绘制位置的逻辑。</p>
                    <ol>
                        <li><b>定位:</b> 找到 <code>SubPaintString</code> 中初始化显示指针的代码: <code>Load Display_StartAddress</code>。</li>
                        <li><b>计算:</b> 计算屏幕中央的大概地址。屏幕为16x16，中央约在第7行第6列。地址 = <code>0F00 + 7 * 16 + 6 = 0F76</code>。</li>
                        <li><b>修改:</b>
                            <ul>
                                <li>在数据区定义新标签: <code>ScreenCenter, HEX 0F76</code>。</li>
                                <li>在 <code>SubPaintString</code> 中，将 <code>Load Display_StartAddress</code> 改为 <code>Load ScreenCenter</code>。</li>
                            </ul>
                        </li>
                    </ol>
                    <p>这样只修改了配置，不影响核心逻辑，是安全高效的方式。</p>
                </div>
            </div>
            
            <div class="flashcard">
                <div class="flashcard-question">问题 2: 如何修改代码，让字符串显示完毕后，从头开始无限循环播放？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p><b>思路:</b> 需要修改 <code>SubPaintString</code> 中检测到字符串结束符 (0) 后的行为。</p>
                    <ol>
                        <li><b>定位:</b> 找到判断字符是否为0并跳转到 <code>PS_Done</code> 的逻辑。</li>
                        <li><b>修改:</b> 当检测到字符为0时，不再跳转去结束程序，而是执行以下操作：
                            <ol>
                                <li>重新加载字符串的初始地址 (<code>Load StringAddrForPainting</code>)。</li>
                                <li>将这个初始地址存回当前的读取指针 (<code>Store PaintString_Pointer</code>)，完成指针重置。</li>
                                <li>跳转回主循环的开头 (<code>Jump PS_Loop</code>)。</li>
                            </ol>
                        </li>
                    </ol>
                     <p>这样程序就会在结束后重置状态，实现无限循环。</p>
                </div>
            </div>

            <div class="flashcard">
                <div class="flashcard-question">新增问题: 如何修改代码，将绘制的颜色从“白底黑字”变为“黑底白字”？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p><b>思路:</b> 需要修改两处：清屏的颜色和绘制字符时判断颜色的逻辑。但最简单的方法是修改Font数据。</p>
                    <ul>
                        <li><b>最简单的方法 (修改数据):</b> 全局替换Font数据区的所有 <code>HEX 0000</code> 为 <code>HEX FFFF</code>，并将所有 <code>HEX FFFF</code> 替换为 <code>HEX 0000</code>。同时，修改 <code>SubClearDisplay</code> 中的清屏颜色为黑色 (<code>HEX 0000</code>)。这是最直接且无需修改复杂逻辑的方法。</li>
                        <li><b>修改代码逻辑 (更复杂):</b> 在 <code>SubPaintChar</code> 内部，当从Font数据区加载一个像素值后，不直接写入，而是先判断。如果值是 <code>0000</code>，则加载 <code>FFFF</code> 再写入；反之亦然。同时，清屏颜色也要改成黑色。</li>
                    </ul>
                </div>
            </div>

        </section>

        <section class="section">
            <h2>Part 3: 核心理论知识问答</h2>
            <p>这部分涵盖了关于进程、内存和I/O的经典面试问题。</p>
            
            <div class="flashcard">
                <div class="flashcard-question">问题: 什么是进程(Process)，它和程序(Program)有什么区别？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p><b>程序 (Program)</b> 是一个静态的文件，是存储在硬盘上的一系列指令的集合。</p>
                    <p><b>进程 (Process)</b> 是程序的一次动态执行过程，是操作系统资源分配的基本单位。一个程序可以有多个进程。进程包含了程序代码、程序计数器、寄存器、栈、堆和数据段等。</p>
                </div>
            </div>

            <div class="flashcard">
                <div class="flashcard-question">新增问题: 什么是上下文切换 (Context Switch)？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p>上下文切换是操作系统暂停一个正在运行的进程，并恢复另一个之前被暂停的进程的过程。这个过程包括：</p>
                    <ol>
                        <li>保存当前进程的状态（CPU寄存器、程序计数器、内存管理信息等）到其进程控制块 (PCB)。</li>
                        <li>加载下一个要执行进程的上下文信息从其PCB到CPU寄存器。</li>
                    </ol>
                    <p>上下文切换是实现多任务操作系统的核心，但它本身是有开销的，因为它不执行任何有用的用户工作。</p>
                </div>
            </div>
            
            <div class="flashcard">
                <div class="flashcard-question">问题: 请解释一下计算机的内存层次结构 (Memory Hierarchy)。</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p>它是一个金字塔模型，根据<b>速度、成本、容量</b>将存储器分级：</p>
                    <ul>
                        <li><b>顶层 (最快,最贵,最小):</b> CPU寄存器, 高速缓存 (Cache)。</li>
                        <li><b>中间层:</b> 主存 (RAM)。</li>
                        <li><b>底层 (最慢,最便宜,最大):</b> 二级存储 (SSD, HDD)。</li>
                    </ul>
                    <p>其核心思想是通过缓存技术，让CPU尽可能访问速度快的上层存储，从而在整体上获得高性能、大容量和低成本的存储系统。</p>
                </div>
            </div>

             <div class="flashcard">
                <div class="flashcard-question">新增问题: 什么是虚拟内存 (Virtual Memory)?</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p>虚拟内存是一种内存管理技术，它为每个进程提供了一个私有的、连续的地址空间（虚拟地址空间），这个空间可以远大于实际的物理内存。</p>
                    <p><b>优点:</b></p>
                    <ul>
                        <li><b>允许运行大于物理内存的程序:</b> 操作系统只将程序需要的部分保存在物理内存中，其余部分放在磁盘上。</li>
                        <li><b>进程隔离:</b> 每个进程都在自己的虚拟地址空间中运行，无法访问其他进程的内存，提高了系统安全性。</li>
                        <li><b>简化内存管理:</b> 程序员不需要关心物理内存的碎片化等问题。</li>
                    </ul>
                </div>
            </div>
            
            <div class="flashcard">
                <div class="flashcard-question">问题: 这个MARIE作业的屏幕显示体现了哪种I/O模型？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <p>体现了<b>内存映射I/O (Memory-Mapped I/O)</b> 模型。</p>
                    <p><b>原理:</b> 将I/O设备的数据和控制寄存器映射到主内存的地址空间中。这样，CPU就可以使用像 <code>Load</code> 和 <code>Store</code> 这样的普通内存访问指令来与设备交互，而无需专门的I/O指令。在这个作业中，我们就是通过 <code>Store</code> 指令向特定内存地址写入值来点亮屏幕像素的。</p>
                </div>
            </div>

        </section>

        <section class="section">
            <h2>Part 4: 系统操作演示</h2>
            <p>这部分指导你如何在Windows上演示查看进程列表。</p>
            <div class="flashcard">
                <div class="flashcard-question">如何在 Windows 上展示进程列表并进行讲解？</div>
                <button class="toggle-answer-btn">显示答案</button>
                <div class="flashcard-answer">
                    <h4>第一步: 打开任务管理器</h4>
                    <p>推荐使用快捷键: 同时按下 <code>Ctrl</code> + <code>Shift</code> + <code>Esc</code>。</p>
                    <h4>第二步: 讲解界面</h4>
                    <ol>
                        <li>确保位于<b>“进程”</b>选项卡。</li>
                        <li>向面试官介绍关键信息列: <b>名称、CPU、内存、磁盘、网络</b>。</li>
                        <li><b>连接理论:</b> 指着一个具体的进程 (如 <code>chrome.exe</code>) 说：“这个列表里的 <code>chrome.exe</code> 就是一个‘进程’，它是我硬盘里那个‘程序’文件的正在运行的实例。”</li>
                        <li><b>(加分项)</b> 解释“应用”和“后台进程”的区别。</li>
                    </ol>
                </div>
            </div>
        </section>

    </div>

    <script>
        // Accordion functionality
        const accordions = document.querySelectorAll(".accordion");
        accordions.forEach(acc => {
            acc.addEventListener("click", function() {
                this.classList.toggle("active");
                const panel = this.nextElementSibling;
                if (panel.style.maxHeight) {
                    panel.style.maxHeight = null;
                } else {
                    panel.style.maxHeight = panel.scrollHeight + "px";
                }
            });
        });

        // Flashcard functionality
        const toggleButtons = document.querySelectorAll(".toggle-answer-btn");
        toggleButtons.forEach(btn => {
            btn.addEventListener("click", function() {
                const answer = this.nextElementSibling;
                if (answer.style.display === "block") {
                    answer.style.display = "none";
                    this.textContent = "显示答案";
                } else {
                    answer.style.display = "block";
                    this.textContent = "隐藏答案";
                }
            });
        });
    </script>

</body>
</html>

